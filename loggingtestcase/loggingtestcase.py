'''
Created on Dec 22, 2016

@author: Chad Rosenquist
'''
import unittest

'''
This class captures the logfile output.  If the test passes,
the output is thrown away.  If the test fails, the output
is displayed.

Properties:
    captured_logs - The captured logs files generated by the assertLogs() context manager.
    testlogger - Set the logger.  The default is the root logger.
    testlevel - Set the log level.  logging.CRITICAL, logging.ERROR, ...
            The default is logging.INFO.
    
    Note: testlogger and testlevel are not named logger and level to ensure
          the names do not conflict with any super class variables.
'''
class LoggingTestCase(unittest.TestCase):
    
    def __init__(self, methodName='runTest', testlogger=None, testlevel=None):
        super().__init__(methodName)
        self.testlogger = testlogger
        self.testlevel = testlevel
        self.captured_logs = None

    def run(self, result=None):
        '''
        Runs the test case, capturing logs.  If the test fails or errors, the logs are displayed.
        '''        
        # Extremely tightly coupled with how unittest.TestCase and unittest.TestResult are implemented!!!
        # If these classes change, this class could break!
        
        if result is None:
            super(LoggingTestCase, self).run(result)
        else:
            before_failures = len(result.failures)
            before_errors = len(result.errors)
            
            '''
            Run the test case, capturing logs.
            assertLogs throws an AssertionError if no logging is written.  Because there could be
            test cases that do not log anything, this code captures that exception and ignores it.            
            '''
            try:
                with self.assertLogs(logger=self.testlogger, level=self.testlevel) as self.captured_logs:
                    super(LoggingTestCase, self).run(result)
            except AssertionError as assertion_error:
                if (len(self.captured_logs.records) == 0) and ("no logs of level" in str(assertion_error)):
                    pass
                else:
                    raise
            
            after_failures = len(result.failures)
            after_errors = len(result.errors)           
        
            # If the number of failures or errors increased, add the logs to the output
            # for that test case.
            if len(self.captured_logs.records) != 0:
                if after_failures > before_failures:
                    result.failures[-1] = (result.failures[-1][0], result.failures[-1][1] + "\n" + self._capture_logs_to_string(self.captured_logs))
                
                elif after_errors > before_errors:
                    result.errors[-1] = (result.errors[-1][0], result.errors[-1][1] + "\n" + self._capture_logs_to_string(self.captured_logs))
    
    
    def _capture_logs_to_string(self, capture_logs):
        '''
        TO DO: Format the output better.
        '''
        return str(capture_logs.output)


